# Problem 1

The full code for our integrator and to generate the plots can be found in `problem1.py`. For ease of notation, we define these shorter function names for calling numpy built ins. 

```python
import numpy as np
pi=np.pi
cos=np.cos
arctan=np.arctan
sqrt=np.sqrt
from scipy.integrate import quad
```

*One can work out the electric field from an infinitessimally thin spherical shell of charge with radius R by working out the field from a ring along its central axis, and integrating those rings to form a spherical shell.* 

The field from a ring of radius `r` will exert a force of `2*pi*cos(arctan(r/y))` at a distance `y` along it's axis. Therefore, to determine the electric field at distance `x` from the center of the sphere, we must integrate over `y` from `x-R` to `x+R`

```python
2*pi*sqrt(R**2-(x-y)**2)/(R**2+y**2)*cos(arctan(sqrt(R**2-(x-y)**2)/y))
```

For our custom integrator, I stole Jon's code and modified it so that it wouldn't crash when the max reccursion depth was encountered, setting a custom max depth of 10. 

```python
def integrate(fun,a,b,tol,rec_level=0):
    """Integrates fun over the interval [a,b] with adaptive 5-point integral"""
    x=np.linspace(a,b,5)
    dx=x[1]-x[0]
    y=fun(x)
    i1=(y[0]+4*y[2]+y[4])/3*(2*dx)
    i2=(y[0]+4*y[1]+2*y[2]+4*y[3]+y[4])/3*dx
    myerr=np.abs(i1-i2)
    if myerr<tol:
        return i2
    elif rec_level>=10:
        print("WARNING: recursion level 10 has been reached, stopping here.")
        print(f"WARNiNG: Error is still too large, myerr={myerr}")
        return return i2
    else:
        # Reccusion step
        mid=(a+b)/2
        int1=integrate(fun,a,mid,tol/2,rec_level+1)
        int2=integrate(fun,mid,b,tol/2,rec_level+1)
        return int1+int2
```

*Use both your integrator and scipy.integrate.quad to plot the electric field from the shell as a function of distance from the center of the sphere.*

Here's what the main body of this code looks like.

```python
"""main"""
# Set up the integral
R=1      #Radius of the sphere, (charge density is assumed to be 1)
tol=0.01 #Error Tolerance
xarr=np.arange(0,8,1/4) #Distances from center 0 to evaluate integral at
result_integrate=[] #Stores the values returned by our integrator
result_quad=[]      #Stores the values returned by scipy's integrator 
# Integrate over y for each distance that we care about
for x in xarr:
    def fun(y,R=R,x=x): 
        return 2*pi*sqrt(R**2-(x-y)**2)/(R**2+y**2)*cos(arctan(sqrt(R**2-(x-y)**2)/y))
    a,b=x-R,x+R
    print(f"DEBUG: x{x}, R{R}, a{a}, b{b}")
    #Apply Custom integrator
    result_integrate.append(integrate(fun,a,b,tol))
    #Apply Scipy's Fortran 'quadrature' integrator
    result_quad.append(quad(fun,a,b)[0])
```

*Make sure the range of your plot covers regions with z < R and z > R. Make sure one of your z values is R. Is there a singularity in the integral? Does quad care? Does your integrator? Note - if you get stuck setting up the problem, you may be able to find solutions to Griffiths problem 2.7, which sets up the integral.*

![nintegrate](https://user-images.githubusercontent.com/21654151/191822176-d42d655b-d0b4-4e7b-90ff-9dcb8ae7a3c0.png)


As you can see, the parameters defined above are such that `x<R` and `x>R` (I have renamed `z` to `x`). The following plot was generated by the code above. As you can see, there is a singularity at `x=R`. Quad doesn't care but our integrator doesâ€”the way we wrote ours, it returns nan values at the singularities, which is why there is no orange line on that little section of the code. 




